<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[obsidian]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>obsidian</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 02 May 2025 05:32:02 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 02 May 2025 05:31:42 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[1.1 정보는 비트와 컨텍스트로 이루어진다]]></title><description><![CDATA[ 
 <br><br>텍스트는 비트로 이루어지며, 그 내용은 해석에 따라 달라진다.<br>
즉, 컨텍스트에 따라 달라진다.<br>예시를 들자면, 숫자에 대한 해석이 있다. 일련의 비트를 "정수"로 해석하는지, "실수"로 해석하는지에 따라 그 값이 달라진다. 텍스트의 경우에는 아스키코드로 해석하거나, 유니코드로 해석하냐에 따라 달라질 수 있다.<br>간단하게, 0000...1000001 는 무엇인가?<br>
가장 간단하게는 65, 또는 "A", 소수라고 생각하고 부동소수점으로도 생각해볼 수 있다.<br>JS의 실행 컨텍스트<br>
<a rel="noopener nofollow" class="external-link" href="https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8" target="_blank">https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8</a>]]></description><link>articles/chapter1/1.1-info=bits+context.html</link><guid isPermaLink="false">articles/chapter1/1.1-Info=Bits+Context.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate></item><item><title><![CDATA[1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다]]></title><description><![CDATA[ 
 <br><br>C 프로그램의 "hello world" 를 예시로 들자면,<br>전처리 단계(pre-processor)<br>
먼저, .c 파일은 전처리기(pre-processor)을 통한 전처리 과정을 거친다. 이 과정에서는 # 으로 시작하는 문장을 실행한다. 대표적으로 #include &lt;stdio.h&gt; 가 있다. 이 과정을 거치고 나서는 .i 로 끝나는 새로운 파일이 생성된다.<br>컴파일 단계(compiler)<br>
.i 파일을 .s 파일로 변환한다. 즉, 어셈블리어로 변환된다. 여기까지는 사람이 해석할 수 있는 텍스트 파일이다. 이후 과정부터 생성되는 파일은 사람이 해석할 수 없는 바이너리 파일이 생성된다.<br>어셈블리 단계(assembler)<br>
변환된 어셈블리어 텍스트 파일을 재배치 가능한 목적프로그램 으로 변환한다. 여기서부턴 바이너리 파일로 사람이 해석할 수 없다. 재배치 가능한 이 어떤 의미인지 추측해보자면, 전체를 함수화하여 여러 곳에서 호출 가능하게 만드는 과정으로 예상된다. 예를 들어 printf.o 파일을 통해 어디서든 printf 를 사용하는 것과 유사하지 않을까?<br>링크 단계(linker) 필요한 여러 목적파일(.o) 을 합치는 과정이다. hello 프로그램에서는 hello.o 와 printf.o 가 합쳐진다.<br>이렇게 만들어진 실행파일 hello 파일은 메모리에 적재되어 시스템에 의해 실행된다.]]></description><link>articles/chapter1/1.2-translate_program.html</link><guid isPermaLink="false">articles/chapter1/1.2-Translate_Program.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate></item><item><title><![CDATA[1.3 컴파일 시스템이 어떻게 동작하는지 이해하는 것은 중요하다.]]></title><description><![CDATA[ 
 <br><br>
<br>프로그램 성능 최적화하기
<br>링크 에러 이해하기
<br>보안 약점 피하기
]]></description><link>articles/chapter1/1.3-importance_of_understanding_compiler.html</link><guid isPermaLink="false">articles/chapter1/1.3-Importance_of_Understanding_Compiler.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate></item><item><title><![CDATA[1.4 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다.]]></title><description><![CDATA[ 
 <br><br>hello 라는 바이너리 파일은 디스크에 저장되어 있다.<br>
다음의 명령어를 통해 우리는 파일을 실행시킨다.<br>linux&gt; ./hello  
hello world  
linux&gt;
<br>shell 은 커맨드라인 인터프리터로 명령어를 입력받고 그 명령을 실행한다.<br>
내장 shell 명령어가 아니라면, 실행파일의 이름으로 판단하여 그 파일을 로딩하여 실행시켜준다.<br><br><br>컴포넌트 간의 정보를 전달한다. word 라는 고정 크기의 바이트 단위로 전송하게 된다.<br>
한 개의 워드가 가지는 바이트 수는 시스템 마다 가지는 기본 시스템 변수이다.<br>
대부분은 4바이트 또는 8바이트를 가진다.<br><br>입출력 장치는 외부세계와 시스템 간의 연결을 담당한다. 키보드, 마우스, 디스플레이 등등의 예시가 있다.<br>
입출력 장치는 입출력 버스, 컨트롤러 나 어댑터 를 통해 연결된다.<br>
컨트롤러와 어댑터의 차이는 패키징(packaging) 에 있다.<br>
컨트롤러는 그 자체가 칩셋이거나 머더보드(시스템의 인쇄기판)에 장착되어 있지만,<br>
어댑터는 머더보드에 장착되는 일종의 카드이다.<br>
하지만, 이 둘은 입출력 버스와 입출력 장치간의 정보를 주고받도록 도와준다.<br><br>프로세서가 프로그램을 실행하는 동안 데이터와 프로그램을 모두 저장하는 임시 저장장치이다.<br>
물리적으로는 DRAM(Dynamic Ramdom Access Memory) 로 구성되어 있다.<br>
논리적으로는 연속적인 바이트들의 배열로 0부터 시작해서 고유의 주소를 가진다.<br>
프로그램을 구성하는 기계어 인스트럭션은 다양한 바이트를 가진다.<br>
데이터 또한 그 타입에 따라 크기가 다양하다. C 언어의 short, int, long long 등을 예시로 들 수 있다.<br><br>주처리장치(CPU) 라고도 불리는 이 장치는 <a class="internal-link" data-href="#메인 메모리" href="about:blank#메인_메모리" target="_self" rel="noopener nofollow">메인 메모리</a> 에 저장된 명령어를 해독(실행)하는 엔진이다.<br>
중심에는 워드 크기의 저장장치(레지스터) 인 프로그램 카운터(PC) 가 존재한다.<br>
PC 는 기계어 명령어를 가리키고 있다.<br>
프로세서는 전원이 공급되는 순간부터 계속 다음과 같은 행위를 반복한다.<br>
<br>PC 가 가르키는 명령어를 수행한다.
<br>PC 값을 다음으로 업데이트한다.
<br>PC가 가르키는 명령어, 즉 인스트럭션은 인스트럭션 집합 구조(Instruction Set Architecture) 로 정의된다.<a data-footref="isa_각주" href="about:blank#fn-1-bfe91b37a104dbed" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a><br>
하나의 인스트럭션은 규칙적으로 실행되며, 여러 단계를 거칠 수도 있다.<br>
업데이트되는 다음의 PC 값은 메모리상 연속일수도, 아닐수도 있다.<br>
프로세서가 실행하는 인스트럭션을 쪼갠 단순한 동작은 메인 메모리, 레지스터 파일, 수식/논리 처리기(ALU) 을 순환한다.<br>
레지스터 파일은 고유의 이름을 갖는 각각의 워드 크기의 레지스터 집합으로 이루어진다.<br>
ALU는 새 데이터와 주소 값을 계산한다.<br>다음은 단순한 동작의 예시이다.<br>
<br>적재(Load): 메인 메모리에서 레지스터로 바이트 또는 워드의 값을 복사한다.
<br>저장(Store): 레지스터에서 메인 메모리로 바이트 또는 워드의 값을 복사한다.
<br>작업(Operate): 두 레지스터의 값을 ALU로 복사해서 수식연산을 시행한 뒤, 결과를 레지스터에 저장한다.
<br>점프(Jump): 인스트럭션 자신으로부터 한 개의 워드를 추출하고, 이것을 PC에 복사한다.
<br>최신 프로세서는 실행 속도를 위해 복잡한 방식을 사용한다.<br>
이런 점에서 인스트럭션의 효과 와 실제 구현 으로 인스트럭션 집합 구조 와 프로세서의 마이크로구조 를 구별할 수 있다.<br><br><br><br>각 하드웨어 조직에서 조직으로 이동할 때는 bus 통해 이동하게 된다.<br>
bus 간의 중간 역할로 I/O bridge, Bus Interface 등 연결 조직이 존재한다.<br>
즉, 조직에서 조직으로 이동하는 과정에는 bus 가 존재한다고 생각하면 된다.<br>
<br>
./hello 입력한다<br>
./hello 라는 문자열이 CPU의 레지스터로 이동한다.<br>
그 후 다시 메인 메모리로 이동한다,

<br>
enter 키를 누른다(= 명령 입력이 끝났음을 알린다)<br>
인스트럭션에 따라 hello 실행파일과 "hello world!\n" 을 포함하는 데이터를 디스크에서 메모리로 이동한다.<br>
디스크에서 메모리로 바로 이동하는 것을 직접 메모리 접근(DMA) 라고 한다.

<br>
hello 실행파일을 실행한다<br>
메모리의 main 루틴의 기계어를 처리한다.<br>
이는 메모리에 있는 "hello world!\n" 을 레지스터로 가져오고, 다시 출력장치로 보내는 것을 포함한다.

<br>실행 과정을 살펴보며 알 수 있는 점은 단순한 프로그램에도 하드웨어 간의 이동이 굉장히 많다. 라는 것이다.<br>
<br>
<br>ISA는 마이크로프로세서가 인식할 수 있는 기계어 명령어들의 집합을 의미하며, CPU 같이 ISA 에 규정된 명령어를 실행하는 물리적 장치를 ISA 의 구현체라고 불린다. <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Instruction_set_architecture" rel="noopener nofollow" class="external-link" href="https://en.wikipedia.org/wiki/Instruction_set_architecture" target="_blank">wikipedia 참고</a><a href="about:blank#fnref-1-bfe91b37a104dbed" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>articles/chapter1/1.4-proccessor_reads_instruction_in_memory.html</link><guid isPermaLink="false">articles/chapter1/1.4-Proccessor_reads_Instruction_in_Memory.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate></item><item><title><![CDATA[1.5 캐시가 중요하다]]></title><description><![CDATA[ 
 <br><br><a data-href="PARA/Project/CS_APP_organize/chapter1/1.4-Proccessor_reads_Instruction_in_Memory#1.4.2 `hello` 프로그램의 실행" href="para/project/cs_app_organize/chapter1/1.4-proccessor_reads_instruction_in_memory.html#1.4.2_`hello`_프로그램의_실행" class="internal-link" target="_self" rel="noopener nofollow">PARA/Project/CS_APP_organize/chapter1/1.4-Proccessor_reads_Instruction_in_Memory &gt; 1.4.2 `hello` 프로그램의 실행</a> 의 마지막 내용처럼<br>Cation
하드웨어 간의 이동에 많은 시간을 사용한다는 것이다.
<br>이를 위해 더 빠르고 가까운 위치에 자주 사용하는 데이터를 저장한다.<br>
이를 통해 복사 과정을 보다 빠르게 만든다.<br>
이러한 저장장치를 캐시 메모리 라고 한다.<br>큰 것보다는 작은 것이, 먼 곳보다 가까운 곳에 있는 것이 빠르다는 점을 이용한다.<br>
대표적으로 L1 캐시, L2 캐시, 심지어 L3 캐시도 존재한다.]]></description><link>articles/chapter1/1.5-cache_is_important.html</link><guid isPermaLink="false">articles/chapter1/1.5-Cache_is_important.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate></item><item><title><![CDATA[1.6 저장장치는 계층 구조를 이룬다]]></title><description><![CDATA[ 
 <br><br>위의 캐시의 개념을 확장하여, 메모리 간의 계층구조 를 구성할 수 있다.<br>
레지스터를 L0, 1차 캐시를 L1 등등으로 L3까지 존재하며,<br>
그 다음엔 메인 메모리, 보조저장장치, 네트워크 분산 시스템 등등이 있다.<br>Important
하위 저장장치의 캐시는 상위 저장장치이다.
<br>예를 들어, L2 캐시의 캐시는 L1 캐시가 관리한다.<br>
하위 메모리에 대한 접근을 줄이기 위해 상위 메모리에 저장하는 것이다.<br>이게 응용된 분야라면, Redis 같은 데이터베이스가 있지 않을까<br>redis 가 캐시로서 작동하는 이유:<br>
인메모리 형식으로 작동하는 No-SQL 로 메모리에서 사용되기 때문에,<br>
스토리지나 디스크에 비해 빠른 속도로 동작할 수 있다.<br>
따라서, 다른 데이터베이스에 대한 캐시 역할을 수행할 수 있다.]]></description><link>articles/chapter1/1.6-hierarchy_of_memory.html</link><guid isPermaLink="false">articles/chapter1/1.6-Hierarchy_of_Memory.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate></item><item><title><![CDATA[1.7 OS는 하드웨어를 관리한다]]></title><description><![CDATA[ 
 <br><br><br>소프트웨어(Application Programs) 가 하드웨어(Processor, Main Memory, I/O Device) 를 이용하기 위해서는 OS 를 반드시 거쳐야 한다.<br>
<br>하드웨어에 대한 접근을 제한하기 때문에, 잘못된 하드웨어 사용을 막을 수 있다.
<br>Application Programs 에서 간단하고 일관된 방법으로 하드웨어를 사용하게 할 수 있다.
<br>위의 목적을 이루기 위해, 아래와 같은 추상화가 이루어진다.<br>
<img alt="PARA/Project/CS_APP_organize/chapter1/imgs/abstractions_provided_by_os.png" src="lib/media/abstractions_provided_by_os.png"><br>즉, files 는 I/O devices 의 추상화이고,<br>
Virtual Memory 는 Main Memory, I/O devices 의 추상화,<br>
Processes 는 Processor, Main Memory, I/O devices 의 추상화이다.<br><br>현대의 OS는 프로그램에 대해 다음과 같은 환상 을 준다.<br>
<br>프로세서(CPU), 메인 메모리, I/O device 에 대한 독자적인 이용하는 것처럼 보인다.
<br>프로세서가 단 하나의 프로그램의 순서를 철저히 지키는 것처럼 보인다. 간섭없이
<br>해당 프로그램의 코드와 관련 데이터가 현재 메모리에 있는 유일한 정보인 것처럼 보인다.
<br>
"프로세서" 라는 개념을 통해 위와 같은 착각을 일으킬 수 있었다.<br>
즉, "프로세서" 와 "프로그램" 은 다른 개념이다.
<br><br>프로세스는 서로 배타적으로 하드웨어를 이용하면서, 동시에 여러개의 프로세스가 작동하는 것처럼<br>
"보인다." "동시에" 라는 의미는 사실 한 프로세스의 명령어가 다른 프로세스의 명령어들 사이에 끼어들어서 작동하는 것으로 구현된다.<br>
실제로, 보통 프로세스는 CPU의 개수보다 많이 돌아간다.<br>위의 "동시에" 작동하는 것처럼 보이기 위해 사용하는 각 프로세스간의 명령어 간 움직임은<br>
라고 알려진 메카니즘에 의해 동작한다.<br>멀티프로세서() 는 물리적으로 여러 프로그램을 동시에 돌릴 수 있지만,<br>
남은 논의에서는 일단 배제한다.(1.9.2 절에서 다시 언급된다.)<br>OS는  을 위해,  의 상태 정보를 수집하고, 추적한다.<br>
이 상태정보를  라고 부른다.<br>
이 상태 정보에는 PC(), 레지스터 파일, 메인 메모리의 내용 등이 있다.<br>
여러 프로세스를 동시에 작동시키기 위해,<br>
프로세스에서 필요한 다음 명령어 사이사이에 다른 프로세스의 명령어를 실행한다.<br>
이 때 온전한 실행을 위해, 프로세스의 상태 정보를 수집, 추적하는데, 이를  라고 한다.
<br>해당 내용을 hello 프로그램 실행에 적용해보자.<br>
처음에는 shell 프로세스가 동작중이다. ./hello 를 통해 실행시키면,<br>
./hello 에 대한 프로세스가 생성되며 해당 프로세스가 종료되면 다시 shell 프로세스로 돌아온다.<br>프로세스 간의 전환은  이 담당하게 된다.<br>
 은 OS 코드의 일부로 항상 메모리 위에 존재한다.<br>프로세스가 OS에게 특정한 요청을 할 때는  에게 제어를 넘기는  라는 특수한 함수를 호출한다.<br> 은 분리된 프로세스가 아닌, 시스템이 프로세스를 제어하기 위해 사용하는 코드와 자료 구조의 모음이다.<br>
시스템이 프로세스를 제어하기 위해 사용하는 코드와 자료구조의 모음.<br>
프로세스가 아닌 운영체제의 일부이다.<br>
프로세스는  을 통해 운영체제를 거쳐 하드웨어 자원을 이용하게 된다.
<br> 는 컴퓨터과학 분야 뿐만 아니라 개발에서도 종종 보인다.<br>
JS: 실행 컨텍스트, golang: context 패키지<br>
JS에서는 실행 엔진이 코드를 실행하기 위해 필요하며, golang 은 다른 고루틴에게 정보 전달용이다.<br>
즉, 다른 함수나 엔진 등 외부에 정보를 전달하는 목적으로 사용된다.<br>OS 에서도 마찬가지로, 다른 프로세스로 넘어가기 위해 기존의 프로세스를 보존하기 위한 정보를  로 저장한다.<br>비슷한 느낌의 용어로  가 있다.<br>참고자료: <a data-tooltip-position="top" aria-label="https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4" rel="noopener nofollow" class="external-link" href="https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4" target="_blank">inpa 찬양해</a><br>
잦은  은 오버헤드로 인해 오히려 성능 하락을 일으킬 수 있다.<br>
 를 위해 해당 프로세스에 대한 정보가 담긴  을 프로세스 생성과 동시에 메모리에 저장한다.<br>
프로세스 전환을 위해서는 해당하는 프로세스의  를 읽어야하기 때문에 작업에 비해 너무 많은 프로세스는 오히려 성능 하락을 일으킬 수 있다.<br>비슷하게 스레드에서도  라는게 존재하여 비슷한 역할을 한다.<br>
스레드에서는  등의 동기화 기법을 사용한다.<br>
 에서는 공유된 자원에 대한 동시 접근에 의한 문제점이 발생할 수 있다.<br>
이는 프로세스와는 달리(프로세스도 공유하는 방법이 존재하긴한다.) 스레드는 자원을 공유하기 때문에,<br>
이에 대한 동시 접근이 가능하며, 이로 인해 잘못 업데이트 된 경우,  이라고 부른다.<br><br>프로세스를 여러개의 실행 단위로 나눈 것을  라고 부른다.<br>
하나의 프로세스에서  는 코드와 전역 데이터를 공유한다.<br>
여러 프로세스보다 데이터를 공유하기 편하기 때문에, 효율적이며 점점 중요도가 올라가고 있다.<br>
 를 여러 개로 나눈 실행 단위.<br>
 끼리는 코드와 데이터 등 프로세스의 자원을 공유한다.
<br><br> 가  에 온전한 접근을 하는 것처럼 보이게 만드는 추상화를  라고 한다.<br>
이를 통해 각각의  는 통일된 메모리에 대한 "시각"을 가진다.<br>
이는  라고 한다.<br> 에서는 아래의 그림과 같다. (다른  계열 시스템도 비슷하다.)<br>
<img alt="PARA/Project/CS_APP_organize/chapter1/imgs/process_virtual_address_space.png" src="lib/media/process_virtual_address_space.png"><br>
(주소는 "아래에서 위" 방향으로 증가한다.)<br>가장 위는 모든 프로세스에서 공통인 OS의 코드와 데이터가 존재한다.<br>
아래 쪽에는 유저에 의해 정의된 코드와 데이터가 존재한다. <br>이러한 추상화를 통해, 프로세스는 메모리를 특정한 목적으로 분리된 영역으로 이루어진 것처럼 본다.<br>
후에 자세히 다루지만, 여기서 간단하게 다룬다. (밑에서 위 방향으로 살펴본다.)<br>
<br>
<br>
코드는 모든 프로세스가 동일한 고정된 주소에서 시작된다.<br>
그 다음으로 데이터 구역으로 C언어의 전역변수에 대응되는 영역이 존재한다.
모든 프로세스가 동일한 고정된 주소를 가지면, 충돌이 나지 않을까?<br>
이를 방지해주는 것이  의 역할로, 각 프로세스가 보는 주소는 같지만,<br>
실제 메모리상의 주소는 다르다. 프로세스가 보는 주소와 실제 메모리상의 주소를,  가 맵핑해준다고 볼 수도 있다. (7장-linking 에서 더 살펴본다.)

<br>
<br>
 으로  는 고정된 것과는 다르게, 런타임에 동적으로 늘어나고 줄어들 수 있다. C언어에서는 malloc, free 함수를 통해 조절한다. (9장 - virtual memory에서 다룬다.)

<br>
<br>
중간에는  가 존재한다. C언어에서는 예를 들어, 기본 라이브러리와 수학 라이브러리 등이 있다. 이 개념은 강력하지만, 꽤 어려운 개념으로 7장-dynamic linking에서 더 배운다.

<br>
<br>
 과 유사하게 동적으로 늘어나고 줄어든다.<br>
단,  에 이용된다. 각 함수가 호출될 때 늘어나며, 함수가 반환할 때 줄어든다.<br>
3장에서 자세히 다루게 된다.

<br>
<br>
 이 사용하는 영역으로 프로그램은 사용할 수 없다.<br>
이 곳에 있는 내용은  에게 요청하여 간접적으로 접근해야만 한다.

<br> 는 하드웨어와 OS 소프트웨어의 정교한 상호작용이 필요하다.<br>
예를 들어, 물리적 주소와 가상의 주소간의 관계는 디스크에 저장되고,  를  로서 사용하게 된다. 9장에서 어떻게, 이것이 왜 중요한지 설명한다.<br><br>은 "단순한 bytes 의 조합, 그이상 그이하도 아니다."<br>
모든 I/O 장치, 네트워크는 file 로 모델링 된다.<br>
모든 Input, Output 은 단순히 파일을 읽고, 쓰는 것에 대응된다.<br>이 작고 우아한 개념은 매우 강력하다. 다양한 I/O 장치에 대해 통일된 시각을 제공해주기 때문이다.]]></description><link>articles/chapter1/1.7-os_manage_hardware.html</link><guid isPermaLink="false">articles/chapter1/1.7-OS_manage_Hardware.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate><enclosure url="lib/media/abstractions_provided_by_os.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/abstractions_provided_by_os.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[1.8 시스템은 다른 시스템과 "네트워크"를 이용해 통신한다.]]></title><description><![CDATA[ 
 <br><br>하나의 시스템에 있어서 내트워크는 특별한 장치가 아니다. 여타 I/O 장치와 똑같이 판단할 수 있다.<br>
바이트 조합을 메인 메모리에서 디스크가 아닌 "네트워크 어댑터"에 작성하는 것과 똑같이 볼 수 있다.<br>
반대로, 다른 시스템의 데이터를 메인 메모리로 읽는 것도 비슷하게 볼 수 있다.<br>인터넷같은 전세계적 네트워크가 발달하면서, 서로 다른 시스템간의 정보 복사는 컴퓨터의 중요한 업무가 되었다. 이메일, SNS, WWW, FTP 등등 다양하다.]]></description><link>articles/chapter1/1.8-system_communicate_system_with_network.html</link><guid isPermaLink="false">articles/chapter1/1.8-System_communicate_System_with_Network.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate></item><item><title><![CDATA[1.9 중요한 주제들]]></title><description><![CDATA[ 
 <br><br>시스템은 단순한 하드웨어 그 이상이다.<br>
하드웨어와 소프트웨어가 서로 얽혀, "프로그램을 실행시킨다"는 궁극적인 목표를 달성한다.<br>아래에서는 몇가지 중요한 컨셉을 소개한다. 중요성은 책의 다른 부분에서 더 소개한다.<br><br>시스템의 특정 부분의 발달이 전체 시스템에 끼치는 영향은<br>
해당 시스템을 차지하는 비율과 성능 향샹 폭이다.<br> : 기존에 특정 애플리케이션을 구동하는데 필요한 시간<br>
 : 필요한 시간에서 해당 부분의 발달이 차지하는 비율<br>
 : 해당 부분의 성능 향상 폭(비율)<br>
즉, 해당 부분은 기존에  만큼의 시간이 필요했으며, 성능 향상으로 이제는  의 시간이 필요하다.<br>따라서 성능 향상 이후 걸리는 시간은<br>
따라서, 성능 향상폭  는<br>
이다. 즉, 성능 향상과 차지하는 비율에 비례한다.<br>
성능 향상폭은  로 표현되며,<br>
실질적인 성능 향상이 존재할 경우,  을 넘는다.<br>
간단하게,  로 적으며, 이는 "2.2배의 향상폭"을 의미한다.
<br>재미있는 특이 케이스로는  가 있다.<br>
이 때,  가 무시되므로,<br>
 가 된다.<br><br>: 여러 행위를 동시에 진행하는 시스템의 일반적인 개념<br>
:  를 사용하여 시스템을 빠르게 하는 것<br>
 은 컴퓨터 시스템의 여러 추상화 단계에서 악용될 수 있다.<br>
(여러 오작동을 일으킬 소지가 있다는 의미같다)<br>아래에서는 3가지 단계로 살펴보며, 시스템 계층 상 높은 것에서 낮은 것순으로 살펴본다.<br><br>
스레드를 통해, 하나의 단일 프로세스에서 여러 개의  를 가질 수 있다.<br>
이러한 기능은 단일 컴퓨터가 빠르게 여러개의 컨택스트를 오가며 실행하는 것으로  되면서 가능해졌다.<br>
이는 여러 유저가 하나의 웹 서버에 접근하고, 여러 작업을 동시에 하는 등 큰 역할을 한다.<br>최근까지는 실제로는 단일 프로세서로 구성되어  라고 칭했다.<br>
여러개의 프로세서를 단일 OS 커널로 다루게 되면서, 현대에는  이 되었다.<br>멀티 코어 시스템이 발달하면서,  같은 용어도 생겼다.<br>멀티 코어 프로세서는 여러개의 CPU(cores 라고 지칭되는) 이 하나의 단일 칩에 포함된다.<br>
각 코어별로 각자만의 별도의 cache 가 존재하기도 하며, 코어간에 공유하는 cache도 존재한다.<br> 는  이라고도 불린다.<br>
이는 단일 CPU가 여러 개의  를 조절하는 기술을 의미한다.<br>멀티프로세싱은 2가지 측면에서 성능 향상을 이뤄냈다.<br>
<br>동시성을  할 필요를 감소시켰다.
<br>단일 프로그램 또한 빠르게 실행 가능하다.<br>
단, 이는 해당 프로그램이 멀티프로세싱이 원할하게 이루어질 수 있도록 표현되어야 한다.
<br><br>
현대 프로세서는 여러개의  을 실행 할 수 있고, 이를  이라고 부른다.<br>
최근의 프로세서는 한 클럭에 2~4개의  을 실행시킬 수 있다.<br>프로세서는  이라는 기술을 통해, 훨씬 많은 명령어를 한 클럭에서 실행시킬 수 있다.<br>
하나의 명령어() 을 서로 다른 단계() 으로 나누어,<br>
잘 정렬한 후, 병렬적으로 실행한다.<br>하나의 사이클() 에 하나 이상의 명령어() 을 수행하는 프로세서를  라고 한다.<br><br>
현대 프로세서는 특별한 하드웨어가 존재한다.<br>
이 하드웨어는 단일 명령어() 가 여러개의 연산() 을 병렬적으로 처리하게 해준다.<br>
예를 들어, 8 쌍의 float 더하기 연산을 병렬적으로 한번에 처리한다.<br>이미지, 소리, 영상 등의 처리에서 최적화에 사용된다.<br>일부 컴파일러는 자동적으로 해당 최적화를 시도하지만,<br>
더 좋은 방법은 특별한  타입으로 작성하는 것이다. (단, 해당 컴파일러가 지원할 때)<br><br>추상화는 컴퓨터 과학 전반에서 중요한 역할을 한다.<br>API(Application Program Interface) 는 좋은 예시 중 하나이다.<br>
API 는 프로그래머가 내부 구현을 모르는 채로, 해당 코드를 사용할 수 있도록 해준다.<br>각 언어는 다양한 형태와 레벨의 추상화를 지원한다.<br>
자바의 경우 class 가 있으며, C언어에서는 함수 프로토타입이 있다.<br><a data-href="PARA/Project/CS_APP_organize/chapter1/1.7-OS_manage_Hardware" href="para/project/cs_app_organize/chapter1/1.7-os_manage_hardware.html" class="internal-link" target="_self" rel="noopener nofollow">PARA/Project/CS_APP_organize/chapter1/1.7-OS_manage_Hardware</a><br>
에서 이미 다양하면서 중요한 추상화의 예시를 살펴보았다.<br>
ISA() 는 실제 프로세서(하드웨어)의 동작을 코드(소프트웨어)로 추상화한 좋은 예시이다.<br>ISA 를 이용한 코드는 실제 프로세서와 무관하게 실행가능하며,<br>
구현된 프로세서에 따라 다른 비용과 성능을 낼 수 있다.<br>OS에서 3가지의 추상화를 살펴보았다.<br>
<br>: I/O 장치의 추상화
<br>: 프로그램 메모리의 추상화
<br>: 실행중인 프로그램의 추상화
<br>그리고, 여기에 한가지를 추가해서<br>
 이 있다.<br> 는 하나의 컴퓨터 시스템을 추상화한다.<br>
즉, OS, 프로세서, 프로그램 모두를 아우른다.<br>VM은 여러 OS(window, mac OS, Linux) 에서 똑같이 돌아갈 수 있도록 설계된다.<br>]]></description><link>articles/chapter1/1.9-other_important_themes.html</link><guid isPermaLink="false">articles/chapter1/1.9-Other_important_Themes.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate></item><item><title><![CDATA[1.10-Summary]]></title><description><![CDATA[ 
 <br>컴퓨터 시스템은 "하드웨어와 소프트웨어를 결합"해서 애플리케이션을 구동시킨다.<br>
정보는 비트로 저장되며, 이를 해석하는 방법은 그 맥락() 에 따라 다르다.<br>프로그램은 다른 프로그램에 의해 다른 형태로 번역되어, 아스키코드에서 실행가능한 바이너리 코드로 변한다.<br>프로세서는 메인 메모리에 저장되어 있는 이진 명령어를 읽고 해석한다.<br>
컴퓨터는 데이터 읽고 쓰기에 많은 시간을 할당한다.<br>
하드 디스크, 메모리, I/O 장치, CPU 간에 서로 끊임없이 교환된다.<br>
이를 완화하기 위해  와  라는 개념을 도입한다.<br>
상위 계층의 저장장치의 데이터를 하위 계층이 캐싱을 하여, 더 이상 내려가지 않고, 빠르게 접근한다.<br>
상위 계층은 빠르지만, 비싸기 때문에 용량이 작아진다.<br>
L1 cache 는 빠르지만 몇 KB 등 용량이 작으며, 반대로 SSD 는 몇 TB 로 용량이 매우 크지만, 속도가 cache 에 비해 느리다.(절대적인 속도는 기술의 발전으로 빨라지긴 했다.)<br>OS 커널은 애플리케이션(소프트웨어)와 하드웨어의 중간통로이다.<br>
커널은 아래 3가지 추상화를 제공한다.<br>
<br>:  에 대한 
<br>:  에 대한 
<br>:  에 대한 
<br>는 다른 시스템과 상호작용할 수 있는 방법을 제공한다.<br>
하지만, 시스템 입장에서는 다른 I/O 장치와 차이점이 존재하지 않는다.]]></description><link>articles/chapter1/1.10-summary.html</link><guid isPermaLink="false">articles/chapter1/1.10-Summary.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate></item><item><title><![CDATA[2.1-Infomation_Storage]]></title><description><![CDATA[ 
 <br>컴퓨터는 8bits 단위, 즉  단위(주소로 표현 가능한 가장 작은 단위인) 로 읽는다.<br>machine-level 의 프로그램은 메모리를 기다란 바이트 배열,  로 본다.<br>
모든 바이트는  로 특정된다.<br>
또한, 이러한 가능한  의 모임을  라고 한다.<br>
위의 가상 주소 공간은 하나의 개념적인 이미지로 표현되며, 실제 구현은 DRAM(), flash memory, disk 등등으로 이루어진다.<br>뒤에서, 컴파일러와 실행중인 시스템이 서로 다른 프로그램 객체(프로그램 데이터, 명령어, 컨트롤 정보) 를 저장할 수 있는 관리 가능한 단위로 다루기 위해 메모리를 나누는지 살펴본다.<br>다양한 메카니즘이 프로그램의 다른 저장공간을 할당하고, 다룬다.<br>
이 관리는 virtual address space 에서 이루어진다.<br>
C언어에서의 포인터 값은 해당 데이터의 첫번째를 가르키는 virtual address 이다.<br>C언어 컴파일러는 type 정보와 함께, 적절한 machine-level 코드를 작성한다.<br>
컴파일러는 type 정보를 인식하지만, machine-level 코드는 그렇지 않다.<br>
단지, 바이트 블럭으로, 바이트의 배열로 볼 뿐이다.<br><br>2진법으로 표현하기에는 너무 길기 때문에, A~F 를 10~16 에 대응하여 16진법으로 표현하곤한다.<br>
2진법에서 16진법은 4개를 묶어서 하나로 표현하면 되며,<br>
반대로 16진법에서 2진법은 해당 값을 4bit 로 표현하면 된다.<br>2진법에서는  꼴은 0이  개, 1이 1개 오는 비트 배열로 표현가능하다.<br>
16진법에서는  일 때,  개의 0이 오고,  값에 따라 마지막 숫자가 달라진다.<br><br>모든 컴퓨터에는  가 존재한다. 이는 포인터 데이터의 사이즈를 나타낸다.<br>
따라서, word size 가  일 때,  의 주소가 가능하다.<br>최근에는 32-bit에서 64-bit 로 넘어가며, 주소 공간이 4GB 에서  바이트로 늘어났다.<br>
대부분의 64-bit 머신은 32-bit 머신을 위한 프로그램을 동작시킬 수 있다.<br>C언어에서 자료형에 따라 사용되는 Byte는 컴퓨터 시스템이 32bit인지, 64bit인지에 따라 다르다.<br>
ISO C99 에서는 시스템에 따라 bit 가 달라지는 것을 방지하기 위해,<br>
int32_t, int64_t 라는 고정된 비트를 사용하는 자료형을 만들었다.<br>신기한 점: unsigned long, unsigned long int, long unsigned, long unsigned int 모두 가능하다.<br>개발자는 환경에 무관한 프로그램을 위해 노력한다.<br>
이를 위한 한가지 방법은 환경에 무관한 데이터 타입의 사이즈일 것이다.<br>
그러나, 하한선이 보장되어있지만, 상한선이 보장되어있지 않아, 32bit에서 64bit로 넘어갈 때<br>
일부 버그가 발생하곤 했다.<br>
그 이유 중 하나로, 32bit 에서의 int 를 포인터를 저장하는 용도로 사용했다는 것이다.<br>
이것은 64bit 시스템에서는 오류가 발생한다.<br><br> : MSB(Most Significant Bit) 부터 LSB(Least Significant Bit) 순으로 저장<br>
 : LSB(Least Significant Bit) 부터 MSB(Most Significant Bit) 순으로 저장<br>
ex) 0x1234567 을 저장할 때, 작은 비트부터 Big Endian 은 01 / 23 / 45 / 67 로 저장한다.<br>
반대로 Little Endian 은 67 / 45 / 23 / 01 로 저장한다.<br>주로 인텔 계열 시스템이 Little Endian 을, IBM, Oracle 계열이 Big Endian 을 사용한다.<br>
"주로" 인 이유는 다 그렇지는 않기 때문이다.<br>
최근의 프로세서는 , 양쪽을 다 지원한다. 하지만, 각 OS에서는 한쪽만 지원하기 때문에<br>
주로 고정된다.<br>이 두 방법에는 일방적인 우위가 존재하지 않기 때문에 선택은 임의적이다.<br>
유래가 걸리버 여행기 ㅋㅋ;;<br>같은 방식을 쓰는 시스템 사이에서는 Byte Ordering 이 문제가 되지 않는다.<br>
그러나, Network 등을 통해 서로 다른 방식을 쓰는 시스템간의 통신에서는 문제가 생길 수 있다.<br>이를 해결하기 위해, 네트워크를 사용하는 프로그램은<br>
송신 측은 "해당 시스템에서 네트워크 표준을 맞추는 변환"을 따라야하며,<br>
수신 측도 "네트워크 표준을 해당 시스템으로 맞추는 변환" 을 갖춰야한다.<br>다음으로는 정수 표현에서 생길 수 있다.<br>
이는 주로 machine-level 프로그램에서 관찰된다.<br>
Little-Endian 으로 생성된 machine-level 코드에서 종종 일어난다.<br>
정수 표현의 일반적인 방법은 왼쪽에서 오른쪽으로 쭉 읽는 것이나, Little-Endian 은 그것과는 다르기 때문이다.<br>마지막으로는 프로그램이 일반적인 타입 시스템을 우회할 때이다.<br>
C언어는 ,  으로 가능하다.<br>
생성된 변수의 타입을 임의로 바꿔 사용하는 방법이지만, 이는 일반적으로 권장되지 않는다.<br>
단, system-level 프로그래밍에서는 유용하고 필요한 경우가 있다.<br>int, float 등의 자료형의 값을 출력하기 위해서,<br>
show_bytes 라는 함수에 매개변수만 casting 해서 출력하는 방법이 있다.<br>
이러한 방법을 서로 다른 시스템에 적용할 때, Endian 에 따라 순서가 다르거나<br>
32bit, 64bit 시스템이냐에 따라 포인터의 값이 달라진다.<br>	typedef unsigned char *byte_pointer;

	void show_bytes(byte_pointer start, size_t len) {
		int i;
		for(i = 0; i &lt; len; i++) printf(" %.2x", start[i]);
		printf("\n");
	}

	void show_int(int x) {
		show_bytes((byte_pointer) &amp;x, sizeof(x));
	}
<br>그리고... 같은 값에 대한 int 와 float 간에 비트패턴에 있어서 13개가 겹치는데,<br>
이 이유에 대해서는 후술한다.(우연이 아님)<br><br>대부분은 ASCII 인코딩 방식을 사용한다.<br>
숫자 표현의 경우, 정수 x에 대해, 0x3x 로 인코딩된다.<br>
예를 들어, 숫자 5는 ASCII 로 0x35 로 표현된다.<br>이는 byte ordering 이나 word 사이즈 관습과 무관하다.<br>
그래서 이진 데이터보다 시스템 독립적이다.<br>여담으로 ASCII 는 영어 위주다보니, 더 넓은 범위로서 Unicode 가 등장했다.<br>
32bit를 사용하는 방법으로 UTF(Universal Character Set) 이 존재한다.<br>
이는 ASCII 의 superset으로 ASCII 를 포함한다. 이에 따라 가변적으로 1~2byte 로도 해석한다.<br>machine-level 프로그래밍에서는 주로 machine-dependent 하다.<br>
이진 코드를 해석하는 방법이 machine 마다 다른 경우가 많기 때문이다.<br><br>컴퓨터가 이진 데이터(0 과 1) 을 다루기 때문에,<br>
0과 1을 다루는 Boolean Algebra 에 대한 지식은 중요하다.<br>
대표적인 연산들로 ~, &amp;, |, ^ 이 있다.<br>
또한 XOR 라는 연산은 어느 한쪽만 True 일때, 결과값이 참이다.(= 두 값이 서로 다를 때)<br>
해당 연산은 0과 1로 이루어진 비트문자열에도 비슷하게 확장가능하다.<br>
Boolean 연산은 전반적으로 일반적인 정수 연산과 비슷한 특징을 가진다.<br>
ring 이라는 대수적 구조는 group이라는 구조의 확장이다.<br>
ring은 더하기에 대해서 group이 성립하는데, 여기에 곱하기라는 연산이 추가되며,<br>
곱하기에 대해 결합법칙과 항등원이 존재한다.<br>
실제로 Boolean Rings 에서 더하기는 XOR 에 대응하고, 곱하기는 &amp; 에 대응한다.<br>
또한, Boolean Rings 는  를 만족하는 특수한 ring 이다.
<br>비트 문자열은 집합의 다른 표현으로 생각해볼 수 있다.<br>
예를 들어 A = {0, 3, 5, 6} 을  로 생각하고, B = {0, 2, 4, 6} 을  로 생각할 수 있다. 이에 대해 &amp;, | 연산자가 모두 집합의 교집합, 합집합에 대응한다.<br>
관련된 알고리즘으로 "비트마스킹"이 있다.<br><br>C언어에서의 bit operation은 위에서 언급한 기호를 그대로 사용한다.<br>
흥미로운 에제로 두 변수의 값 교환이 있다.<br>void inplace_swap(int *x, int *y) {
	*y = *x ^ *y;
	*x = *x ^ *y;
	*y = *x ^ *y;
}
<br>이것이 가능한 이유는  이기 때문이다. 각  라고 설정하고 따라가면 확인 가능하다.<br>이것을 응용해서 다음 함수의 문제점을 찾아보자<br>void reverse_array(int a[], int cnt) {
	int first, last;
	for(first = 0, last = cnt - 1; first &lt;= last; first++, last--) {
	inplace_swap(&amp;a[first], &amp;a[last]);
	}
}
<br>길이가 홀수일 때, 배열의 가운데 값이 0인 문제가 생긴다.<br>
그 이유는  일때,  에서 inplace_swap(&amp;a[k], &amp;a[k]) 라는 연산을 하며,<br>
 이기 때문에 정보가 없어진다.<br>
따라서, 해결책은 가운데에서 즉, index 가 같을 때는 바꾸지 않는 것이다.<br>
first &lt;= last =&gt; first &lt; last<br>bit-level 에서는 마스킹 연산이 자주 사용된다.<br>
마스킹 연산은 특정 구간의 값만을 취하는 연산이다.<br>
예를 들어,  에서 0, 1, 2, 3 위치의 값이 무엇인가? 라고 하면 그 결과는  이다.<br>
이는 원하는 구간만큼 1로 채우고 나머지는 0으로 채운 비트문자열과 &amp; 연산을 취함으로서 구할 수 있다.<br><br>Boolean Operation 과는 유사하지만, 다르게 작용한다.<br>
예를 들어, ! 의 결과값은 0 아니면 1만 가능하다.<br>
그 외로 &amp;&amp; 나 || 연산자가 있는데, 이들은 첫번째 operand 로 전체 결과가 결정되면, 2번째 operand 는 고려하지 않는다.<br>
ex) a &amp;&amp; 5/a 는 divided by zero 가 뜨지 않는다. 또한, p &amp;&amp; *p++ 도 null pointer 참조가 일어나지 않는다.<br><br>&lt;&lt; 은 비트를 왼쪽으로 밀면서, 새로운 공간을 0으로 채운다.<br>
ex)  이 된다.<br>그러나, &gt;&gt; 의 경우는 조금 다르게 작동한다. 크게, ,  2가지가 있다.<br>
: 새로운 공간을  으로 채운다.<br>
: 새로운 공간을 MSB 와 동일한 값으로 채운다. 이는 signed int 에서 유용하다.<br>C언어 표준은 Logical, Arithmetic 을 특정하지 않는다.<br>
단, 대부분의 컴파일러가 signed data 에 대해 Arithmetic 을 사용하고, 개발자도 그렇게 받아들인다.<br>
하지만, unsigned data 에 대해서는 Logical 을 사용해야만 한다.<br>
Java 에서는 &gt;&gt; 을 Arithmetic 으로, &gt;&gt;&gt; 을 Logical 로 이용한다.]]></description><link>articles/chapter2/2.1-infomation_storage.html</link><guid isPermaLink="false">articles/chapter2/2.1-Infomation_Storage.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate></item><item><title><![CDATA[2.2-Integer_Representations]]></title><description><![CDATA[ 
 <br>bit로 Integer 를 표현하는 2가지 방법을 알아본다.<br>
양의 정수를 표현하는 방법과 음의 정수를 포함한 모든 정수를 표현하는 2가지 방법이다.<br>
사실 이 2가지 방법은 수학적 특성이나 machine-level 구현에서 연관성이 있다.<br>
또한, 기존의 표현에서 다른 길이의 표현으로 옮기는 방법에 대해 살펴본다.<br><br>C언어는 다양한 정수형 데이터 타입이 존재한다.<br>
이들은 32bit, 64bit 에 따라 "전형적인" 정해진 Byte 를 점유한다.<br>
기본적으로 음수 표현을 지원하며, unsigned 키워드를 통해 양수만 표현함으로서 범위를 늘릴 수 있다.<br>한 가지 중요한 점은 음수가 가능한 절댓값이 정수보다 1 크다는 점이다.<br>
ex) short :  ~ <br>machine 에 따라 다르기 때문에,<br>
C언어 표준에서 보장하는 범위가 존재한다.<br>
더 작은 범위이며, 양수와 음수의 절댓값 크기가 같다.<br><br> bit의 정수 표현을 이야기하면서, bit vector를  로 표현하거나,<br>
각각의 bit를 표현하기 위해  라고 표현한다.<br>
각각의  는  또는  의 값을 갖는다.<br>우리는 해당 bit vector를 양의 정수를 표현하는 함수로<br>
 를 정의한다. 해당 함수는  길이의 bit vector 를 양의 정수로 바꿔준다.<br>
(Binary 2 Unsigned)<br>
해당 함수는 다음과 같이 정의될 수 있다.<br><br> ex)  <br> bit에 대해 해당 함수의 최댓값, 즉  bit 로 표현 가능한 최대 정수는<br>
  이다.<br>
따라서,  bit에 대한 표현 가능 범위는  이다.<br>
이 함수의 중요한 특징은 특정 정수값  는 그에 해당하는  bit 표현법이 하나로 유일하다는 것이다.<br>
즉, 일대일 맵핑이 가능하다.<br>
 is .(=  + )<br>
 :  (일대일 함수)<br>
 : for ,  is the  (공역과 치역이 같다)
<br>일대응 대응이기 때문에, 특정 정수는 bit vector 로 변환 가능하며, 반대로 bit vector 를 특정 정수로 표현 가능하다.<br>
이를 역함수  라고 표현한다.<br><br>음수 표현은 보통 2의 보수 방식으로 표현된다.<br>
우리는 이 방식을  라고 칭할 것이다. (Binary 2 Two's complement, length )<br><br>여기서 MSB(Most Significant Bit) 는  라고도 불린다. (부호를 결정하기 때문이다.)<br>
양수 표현에 비해 이 마지막 bit,  번째 bit는  의 가중치를 가진다.<br>이로 인해,  가  이라면, 양수,  이라면 음수이다.<br>해당 가중치로 인해, 최솟값은  이며, 그 값은  이다.<br>
반대로 최댓값은  이며, 그 값은  이다.<br>해당 함수 또한, bit vector 와 일대일 대응이 되는  이다.<br>
 is .(=  + )
<br>역시 역함수를  라고 표현한다.<br>2의 보수 즉, 정수 표현에서는 최솟값이 최댓값보다 절댓값이 크다.<br>
구체적으로,  이다. <br>이 점은 간혹 문제를 일으키는데, 비트패턴의 절반은 음수가, 절반은 비음수가 차지한다.<br>
근데,  이 포함되기 때문에, 양수 측이 표현할 수 있는 방법이 하나 적다.<br>Unsigned value 와 Signed Value 간에 다음과 같은 관계가 성립한다.<br><br>특이한 점으로  의 비트패턴은 Unsigned Value 에서는 최댓값, 즉 UMax 이다.<br>
 은 Signed, Unsigned 양쪽다 동일한 비트패턴을 가진다.<br>부호 비트를 사용하는 방법, 1의 보수 방법 등이 있으나,<br>
2의 보수가 편리하기 때문에 2의 보수를 주로 사용한다.<br>N's Complements
 - 길이의 숫자  에 대해,  의 보수는  이다.
<br>여담으로... 수학적 구조 중에 군의 구조를 이룬다고 볼 수 있다.<br>
특히,  에서의 modulo inverse 랑 비슷하게 더하기에 대한 역원으로 볼 수 있다.<br><br>C언어에서는 같은 사이즈의 데이터 간의 casting 은 비트 표현을 바꾸지 않는다.<br>
단, 해석이 바뀌기 때문에 그 값은 다르게 출력된다.<br>
ex) short v = -12345, (unsigned) v 의 값은 53191 이다. (둘의 비트패턴은 동일하다.)<br>비트표현이 바뀌지 않지만, 값은 바뀐다는 점을 이용해,<br>
 라는 함수를 정의한다.(unsigned value 를 signed value 로 해석하기)<br><br>라고 정의할 수 있다. (정의그대로, 2의 보수로 표현된 값을 비트패턴으로, 그것을 다시 Unsigned value 로 해석한다) 단, 범위에 주의해야한다. <br>바로 계산할 수 있는 형태로는<br><br>성립하는 이유는 MSB 가  로 해석되는 것을  로 바꾸는 것이므로  를 더하면 된다.<br>또는, 비트표현에서  자리의 값으로 부호 판별이 되므로,<br><br>라고 할 수 있다.<br> 도 비슷한 논의로 비슷하게 정의가능하다.<br><br><br><br>C언어 표준은 부호 있는 정수 표현에 대해 규정하지 않지만, 대부분의 machine 은 2의 보수법을 사용한다.<br>
보통 정수는 부호 있는 정수 표현으로 저장된다.<br>C언어는 부호 있는 표현, 없는 표현간의 casting 이 가능하다.<br>
표준은 역시 그 방법에 대해서는 규정하지 않는다.<br>
하지만, 대부분의 machine 은 비트패턴을 변하지 않는 상태로의 변환을 지원한다.<br>
앞에서 계속 C언어의 표준과 그 구현을 같이 보고 있다.<br>
표준은 보통 기능 자체를 제시하며, 그 구현은 구현체에 맡기는 경향이 있다.
이에 대한 GPT의 답변은<br>
표준은 기능 제시 위주이며, 구현은 구현체, 컴파일러에게 맡기는 편이라고 한다.<br>
이를  라고 한다고 한다.<br>
그 이유로는 시스템 프로그래밍에 사용되는 만큼, 각 machine 에 맞게 최적화된 구현을 맡기려는 의도가 있다.
<br>각 타입으로의 변환은 문법에 의해 몀명시적(explicit) 일수도, 암시적(implicit) 일 수 있다.<br>이 암시적 변환은 종종 이해할 수 없는 결과를 내거나, 버그를 일으키는 원인이 되기도 한다.<br>
C언어는 음수가 아니라고 가정하고, 부호 있는 정수를 부호 없는 정수로 암시적으로 형변환한다.<br>
이 때,<br><br>의 결과는 False 가 된다.<br>
그 이유는 뒤의  는 부호없는 정수이다. 이에 따라  을 부호없는 정수로 암시적 형변환이 된다.<br>
따라서,<br><br>이므로 False 이다.<br><br>큰 범위의 데이터를 작은 범위의 데이터 축소는 불가능할 수 있지만,<br>
작은 범위의 데이터를 큰 범위의 데이터로 확장하는 것은 가능하다.<br>
각 자료형의 한계값은 limits.h 에 저장되어 있다.<br>
그 안에는<br>
#define INT_MAX 2147483647<br>
#define INT_MIN = (-INT_MAX - 1)<br>
로 표현되어 있다.<br>
이런 표기에는 2의 보수의 비대칭성, 즉 양수 음수의 표현범위가 다르다는 점이 포함되어있다.
<br>Unsigned Number 에 대한 확장은  을 추가해주면 된다.<br>
이 방법을  이라고 한다. 구체적으로,<br>
,<br>
 는  의 길이,  은  의 길이라고 할 때,<br><br>이다.<br>Signed Number 에 대한 확장은 MSB의 값으로 채워주면 된다.<br>
이를  이라고 한다.<br>
,<br>
 는  의 길이,  은  의 길이라고 할 때,<br><br>이다.<br>조금 더 살펴보면, 양수일때는 MSB 가 0이기 때문에  과 동일하다.<br>
반대로 음수일 때는 MSB 가 1이기 떄문에 1을 나열하는 것과 같다.<br>
이 때, 1을 나열하는 것이 정말 같은 값을 표현하는지 생각해보면,<br>
위의 표기를 이용하면,<br><br>이다. MSB 가 1임을 가정했다.<br>
이때,  가 동일해지는 조건을 찾는다. (비트패턴과 그 값은 일대일 대응이다.)<br><br><br>이므로,  는 자명하게  이다.<br><br>
 , we will prove<br><br><br>변환에도 상대적인 순서가 존재한다.<br>
먼저 size 에 대한 변환 후, 부호에 대한 변환을 거친다.<br>
ex) short -&gt; unsigned int<br>
음수인 short 를 변환하면, 먼저 size 를 맞추기 위해 로 채워진다. 그 후, 부호변환이 일어나서<br>
상대적으로 큰 수로 변한다.<br><br>int 를 short 로, 다시 int 로 형변환을 하면, 저장하는 bit가 한번 줄어들었기 때문에<br>
같은 int 지만 값이 달라진다.<br>더 작은 bit의 데이터로 줄어들 때, 그 차이만큼의 bit가 잘린다(truncate).<br>
그 점 때문에 부호없는 정수에 대해,(Unsigned)<br>
 에 대해 bit가 잘려서 길이가  가 된  은 다음의 관계가 성립한다.<br><br>이유는  이하의 bit가 동일하고,  초과의 bit는 가중치가  를 인수로 가지기 때문에,<br>
 값이 0이다.<br>부호 있는 정수와 부호 없는 정수간 변환에 비트의 패턴이 바뀌지 않기 때문에,<br>
부호 있는 정수에서도 비슷한 관계가 성립한다.<br>
단, 부호 있는 정수에서는  이다.<br>
부호 없는 정수로 값을 계산하고, 비트패턴이 안 변한다는 사실을 이용한 것이다.<br><br>암시적 형변환은 티가 잘 나지 않기 때문에 여러 버그의 원인이 되곤한다.<br>	float sum_elements(float a[], unsigned length) {
		int i;
		float result = 0;
		for(i = 0; i &lt;= length - 1; i++)
			result += a[i];
		return result;
	}
<br>이 코드는 length = 0 일 때, 에러가 발생한다.<br>그 이유는, unsigned 인 length 에 0 이 저장되어 있는데, lenth - 1 은 -1 이 아닌, int_max 가 되기 때문에 의도하지 않은 메모리 접근이 발생한다.<br>
따라서, i &lt;= length - 1 를 i &lt; length 로 바꾸면 해결 가능하다.<br>	// library function
	size_t strlen(const char *s);

	int strlonger(char *s, char *t) {
		return strlen(s) - strlen(t) &gt; 0;
	}
<br>32bit 에서 size_t 는 unsigned 로 정의되어 있다.<br>이 코드는 t 가 더 긴 문자열일 때, 즉, strlen(s) - strlen(t) &lt; 0 일 때 문제가 생긴다.<br>
이 때 해당 식의 값은 음수이나, unsigned 로 계산되기 때문에, True 라고 뜬다.<br>
return strlen(s) &gt; strlen(t) 로 해결 가능하다.<br>이러한 미묘한 버그로 인해, 최근 언어에서는 지원 자체를 안하는 경우가 많다.<br>
java 는 모두 부호 있는 정수이며, &gt;&gt; 와 &gt;&gt;&gt; 로 분리하기도 한다.<br>부호 없는 정수는 우리가 수적 해석 없이 비트패턴으로서 해석할 때 도움이 된다.<br>
이것은 우리가  로 해석하는 예시가 있다. 주소 또한 기본적으로 부호가 없다.<br>
또한, 수학 관련 패키지, modulo, 다중정밀도 산술(큰 수에 대한 연산) 같이 숫자가 words 배열로 이루어진 곳에서 도움이 된다.]]></description><link>articles/chapter2/2.2-integer_representations.html</link><guid isPermaLink="false">articles/chapter2/2.2-Integer_Representations.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate></item><item><title><![CDATA[2.3-Integer_Arithmetic]]></title><description><![CDATA[ 
 <br>2개의 양수를 더했는데 결과값이 음수이거나,<br>
x &lt; y 와 x - y &lt; 0 의 결과가 다른 등 종종 컴퓨터는 연산 결과가 상식적이지 않다.<br>
이는 컴퓨터가 표현할 수 있는 수의 범위가 한정적인데서 오는 특징이다.<br>
이러한 특징을 아는 것은 신뢰할 수 있는 코드를 짜는 기반이 된다.<br><br> 인 두  는  bit 로 표현 가능하다.<br>
하지만,  이므로 그 합은  bit 로는 부족하며,  bit 가 필요하다.<br>
 은 산수 연산의 결과값을 온전히 나타낼 수 없다는 의미이다.<br>Lisp 같은 일부 언어는 임의 size 의 산수 연산을 지원하지만,<br>
보통의 언어는 고정된 size 에 대해 지원한다.<br>새로운 더하기 연산자로  를 정의한다.<br>
이 연산자는  bit 에서 + 를 수행하며, 그 결과를 Unsigned 로 표현해준다.<br>
이는 사실 더하기 연산 이후,  를 취하는 것과 같은 결과이다.<br>
 일 때,  로 같은 결과이다.<br>
unsigned 와 int 간의 암시적 형변환을 이유로 허락되지 않은 kernel 데이터에 접근할 수도 있었다.
<br><br><br>산수연산이 해당하는 범위 내로 결과가 나오지 않을 때,  라고 한다.<br> 는  보다 작기 때문에,  ,  는 모두 0보다 작다.<br>
따라서,  가 발생하면 다음이 성립한다.<br><br> 은 을 이룬다. <br>
Group 에서 교환조건(Commutative) 가 추가된 Group 이다.<br>
Group은 어떤 집합이 특정 연산에 대해,

<br>연산 결과가 해당 집합에 있음이 보장(Operation is Closed)
<br>결합법칙이 성립 (Associativity)
<br>항등원이 존재 (Identity element exist)
<br>역원이 존재 (Inverse element exist)

가 성립하는 경우, 해당 연산에 대해 Group 이라고 칭한다.
<br> 이기 때문에 연산의 결과가 예상 범위 내임이 보장되고, 연산에 자유롭게 변형을 가할 수 있다.<br>Group이기 때문에 역원이 존재함이 보장되고 이를  로 정의한다.<br>
이 때,<br><br>로 계산할 수 있다.<br><br>2의 보수에서는  이므로,  가 성립한다.<br>
즉,  bit가 필요할 수 있다.<br>
2의 보수에서는 양극단, 즉 너무 작거나, 클 때의 연산을 잘 정의해야한다.<br><br>해당 연산에서  를 더하고 빼는것은 modulo 연산을 생각하면 유추해낼 수 있다.<br>
너무 큰수에 대해서는 modulo 값이 동일한 채로 줄여야하므로  를 더하고 빼면 된다.<br>2의 보수 표현과 부호없는 정수의 표현 방법이 동일하기 때문에,<br>
피연산자를 부호없는 정수 표현으로 바꿔서 더하기 연산을 실행하고, 다시 2의 보수 표현으로 바꿔도 동일한 값을 얻을 수 있다. 수식으로 정리하면 다음과 같다.<br><br> 라는 점과  가 단순히  라는 점을 감안하면,<br><br>2의 보수법에서는 OverFlow 는<br>
<br> 일때, Positive OverFlow
<br> 일때, Negative OverFlow
<br>	int tadd_ok(int x, int y) {
		int sum = x + y;
		return (sum - x == y) &amp;&amp; (sum - y == x);
	}
<br>위의 예제는 항상 1 을 반환한다.<br>
2의 보수 덧셈은 아벨군이기 때문에, 더하기 연산에 대해 닫혀있다.<br>
따라서, 덧셈의 결과로는 OverFlow 를 감지할 수 없다. 위의 x, y, sum 의 상태를 판단해야한다.<br>	int tsub_ok(int x, int y) {
		return tadd_ok(x, -y);	
	}
<br>이 함수는  일 때, 발생한다.  의 값은 가능한 양수 범위를 벗어난다.<br>
()<br>
따라서  에는 그래도  가 저장된다.<br><br> 에 대하여,<br><br> 에 대하여,  이므로,  가 발생하므로,<br>
 이다. 그 외  에 대하여,  이다.<br>

<br>
<br>find rightmost 1.<br>
 일 때,  을 찾을 수 있다.<br>
이 때,  이다.

<br><br>원래는  인 두  에 대해, 곱하기는 0에서  까지 가능하다.<br>
즉, 이론상  bit 가 필요하다.<br>
C언어에서는 하위  bit 를 알려주는 곱하기 연산이 있다. 이를  로 정의한다.<br>
이는 사실 곱한 값에  를 취한것과 같다.<br><br><br>원래는  인 두  에 대해, 곱하기는  에서  까지 가능하다.<br>
즉, 이론상  bit 가 필요하다.<br>
C언어에서는 하위  bit 를 알려주는 곱하기 연산이 있다. 이를  로 정의한다.<br>
이는 사실 곱한 값에  를 취하고, Unsigned 에서 2의 보수로 변환한 값과 같다.<br><br>사실, Unsigned 에서의 곱하기와 2의 보수에서의 곱하기는 동일하게 작동한다.<br>
양쪽 모두,  방식을 이용한다.<br>
간단하게, 곱셈 연산의 오른쪽 숫자의 비트패턴을 살펴보며, 0이면 패스, 1이면 왼쪽 숫자를 그래도 더하고, 오른쪽 숫자가 왼쪽으로 1 shift 한다.<br>그리고, Unsigned 와 2의 보수법 모두 같은 패턴을 다르게 해석하는 해석의 차이이기 때문에,<br>
같은 비트를 같은 연산으로 처리하므로, 해석법만 맞추면 동일한 값이 나온다.<br>
즉, Unsigned * Unsigned 의 결과값을 bit 로 표현한 것은 signed * signed 을 bit 로 표현한 것과 같다.<br><br>곱하기에 대한 컴파일러 최적화를 위해 상수에 대한 곱을 처리한 다음, 남은 부분을 더하는 것이다.<br>
이를 위해 먼저  꼴의 상수를 먼저 살펴보고, 임의의 상수로 넘어간다.<br>부호 없는 정수 표현에서  에 대해,<br>
,  bit 부호없는 정수 표현으로  는 다음과 같다.<br><br> 이 오른쪽에서  개 추가되었다.<br>
성립하는 이유는  이 추가되면서, 가중치가 정확히  배가 되며, 0으로 채웠기 때문에 연산에서 무시되기 때문이다.<br>이 때,  bit 로 고정된 경우, 일부 정보의 손실이 발생할 수 있지만,<br>
shift 연산도 동일하므로 두 과정을 동일하게 볼 수 있다.<br>
즉,<br><br>이다.<br>2의 보수법에서도 bit-level 연산은 동일하므로,<br><br>이다.<br>
두 경우 모두, OverFlow 가 발생할 수 있다는 점을 조심해야한다.<br>컴파일러는 최적화를 위해, 곱셈을 shifting and adding 으로 처리한다.<br>
예를 들어,   이다.<br>
또는 반대로,  로 표현할 수 있다.<br> 에 대해,  이라고 하고<br>
 중 하나가  의 구간을 가질 때, 다음의 2가지 방법으로 계산할 수 있다.<br>
<br>
<br><br>
위의 2가지 방법과  를 그대로 수행하는 것, 총 3가지 방법 중 가장 빠른 방법은<br>
instruction 의 상대적인 속도 즉, machine-dependant 이기 때문에 machine 마다 다르다.<br>
보통은 적은 수의 연산으로 가능할 때 위의 최적화가 발생한다.
<br>	(x &lt;&lt; (n + 1)) - (x &lt;&lt; m)
	해당 연산 방법에 대해, n 이 MSB 이면 어떻게 되는가?
<br> 의 결과는  이다. 모든 비트 정보가 사라지기 때문이다.<br>
따라서,  이다.<br><br>나누기는 곱셉보다도 훨씬 느리다. 이번에는 오른쪽 shift 를 통해 해결할 수 있다.<br>
logical, arithmetic 은 부호 없는 표현, 부호 있는 표현 각각에 대해 처리해준다.<br>정수 나눗셈은 항상  한다.<br>
이를 명확히 하기 위해 표기를 정리한다.<br>
<br>
<br>
 에 대해,<br>
양수 결과에 대해서는 round down(),<br>
음수 결과에 대해서는 round up() 이다.<br>부호 없는 표현에 대해  shifting 을 이용하는 것은 자연스럽다.<br>
<br><br><br>&lt;&lt; 은 비트를 왼쪽으로 밀면서, 새로운 공간을 0으로 채운다.<br>
ex)  이 된다.<br>그러나, &gt;&gt; 의 경우는 조금 다르게 작동한다. 크게, ,  2가지가 있다.<br>
: 새로운 공간을  으로 채운다.<br>
: 새로운 공간을 MSB 와 동일한 값으로 채운다. 이는 signed int 에서 유용하다.<br>C언어 표준은 Logical, Arithmetic 을 특정하지 않는다.<br>
단, 대부분의 컴파일러가 signed data 에 대해 Arithmetic 을 사용하고, 개발자도 그렇게 받아들인다.<br>
하지만, unsigned data 에 대해서는 Logical 을 사용해야만 한다.<br>
Java 에서는 &gt;&gt; 을 Arithmetic 으로, &gt;&gt;&gt; 을 Logical 로 이용한다.<br>C언어에서는 다음이 성립한다.<br><br> 이다.<br>
이 때,<br>
<br>
<br>
 이다.<br>
따라서,  이다.<br>또한,  shift 의 결과는<br>
  이다.<br>2의 보수법 즉, 부호가 있는 정수에 대한 나눗셈은 조금 더 복잡하다.<br>
우선, 음수에 대해 부호 때문에 MSB 가 보존되는  right shift 가 일어나야한다.<br>2의 보수법으로 표현된 값  와, 부호 없는 정수  에 대해, <br><br>양수에 대해서는 MSB 가 0이므로,  가 동일하게 작동한다.<br>2의 보수에서<br>
 이다.<br>
이 때,<br>
<br>
<br>
 이다.<br>
따라서,  이다.<br>
하지만,  과 다르게,  연산을 사용하므로,<br>
shift 의 결과는   이다.<br>2의 보수법의 음수에 대해서는  이 필요하다.<br>
이는 C언어에서 다음으로 표현된다.<br><br> 은  번째 bit는 0,  이하의 bit에 대해서는  모두 1인 bit 패턴이다.<br>
이를 더하는 것은  이하에서 이 있을 때, 올림을 해준다는 의미이다. 이는 floor 와 의미가 일치한다.<br>또는 다음의 수식으로 이해할 수 있다.<br><br>이는 다음으로 증명가능하다.<br><br> 를 대입하면, 정확히 우리가 원하는 연산을 해준다.<br>이러한 분석을 통해, 2의 보수 표현에 대해  을 사용하는 machine 의 경우,<br>(x &lt; 0 ? x + (1 &lt;&lt; k) - 1: x) &gt;&gt; k = x/2^k
<br>이다.<br>	 function returns x/16 for integer x.
	"No" Division, modulus, multiplication, any conditional, any comparison, any loop.
	x is type int with 32bits, use two's complements. And right shift are performed "arithmetics."
<br>	int div16(int x) {
		int bias = (x &gt;&gt; 31) &amp; 0xF;
		return (x + bias) &gt;&gt; 4;
	}
<br>중요한 포인트는 양수에 대해서는 bias = 0 이며, 음수에 대해서는 16bit의 111...1 이다.<br>
이는 양수, 음수가 MSB 에 의해 판단되며, arithmetic right shift 가 MSB 를 복사한다는 점을 이용한다.<br>2의 보수에서  꼴의 곱셈을 위해,  혹은  을 사용한다는 점은,<br>
대부분의 machine 에서 양쪽 연산을 모두 지원하는 이유 중 하나일 것이다.<br>하지만, 나눗셈에 대해서는 일반적인 방법이 없다.<br>	# define M
	#define N

	int arith(int x, int y) {
		int result = 0;
		result = x*M + y/N;
		return result;
	}
	
	// compile and deCompile...
	
	int optarith(int x, int y) {
		int t = x;
		x &lt;&lt;= 5;
		x -= t;
		if(y &lt; 0) y += 7;
		y &lt;&lt; 3; /* arithmetic shift */
		return x + y;
	}
<br>Answer: <br>
해당 과정을 정리하면,  이며 이는 곱하기에 대한 최적화로  와 같다.<br>
 는  이므로 2의 보수 나눗셈으로 8에 대해 나누고 있다.<br><br>"정수" 연산은 모듈러 연산의 일종이다.<br>
한정된  의 사이즈는 가능한 값의 범위를 제한한다. 또한 이 때문에  가 발생할 수 있다.<br>
2의 보수법은 부호 없는 정수와 똑같은 bit-level 연산을 지원해주는 방법이다.<br>
bit-level 연산에서는 같거나 거의 비슷했다.<br>C언어의 미묘한 행동은 예상치 못한 결과를 낳는다. ]]></description><link>articles/chapter2/2.3-integer_arithmetic.html</link><guid isPermaLink="false">articles/chapter2/2.3-Integer_Arithmetic.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate></item><item><title><![CDATA[2.4-Floating_Points]]></title><description><![CDATA[ 
 <br>Floating Point 는  형태로 표현한다.<br>
매우 큰 수, 0에 근접한 수, 더 일반적으로 실제 연산의 근삿값으로 유용하다.<br>1980년전에는 각자만의 규격으로 소수를 구현했다.<br>
그 당시 컴퓨터 제작자의 관심사는 정확도가 아닌, 속도와 구현의 난이도 였다.<br>1985년, IEEE Standard 754 가 생기면서, 소수 표현과 연산 방법에 대한 표준이 정립되었다.<br>
1976년, Intel 의 8087 chip, 8086 에서 floating point 를 지원하는 칩,<br>
을 디자인했다.<br>
현대에 와서는 대부분의 컴퓨터가 IEEE floating point 를 지원한다.<br>이 챕터에서는 floating point 를 알아보며, round 관련 이슈를 살펴본다.<br>
이는 숫자를 정확히 표현할 수 없기 때문에, 생기는 올림/내림에 의해 발생한다.<br>이후, 사칙연산, 관계 연산자의 수학적 특성을 살펴본다.<br>
또한, 해당 표준이 작고 일관적인 규칙으로 이루어져있으며, 이로 인해 이해하기 쉽고, 우아하다는 것을 이해한다.<br><br>십진법에서,  을  라고 표현하듯이,<br>
이진법에서는,  을  라고 표현할 수 있다.<br>
"." 의 왼쪽은 지수가 양수, 오른쪽은 지수가 음수로 이해할 수 있다.<br>
"." 의 위치를 왼쪽으로 한 칸 움직이면, 2로 나누는 것이 되며, 오른쪽은 2를 곱하는 것으로 해석할 수 있다.<br> 는 해당 자릿수로 나타낼 수 있는 가장 1에 근접한 소수이다.<br>
예를 들어,  이다. 나중에 이러한 표기로  를 사용한다.<br>
십진수에서 특성 소수() 을 표현하지 못하듯이 이진법에서도 불가능한 숫자들이 있다.<br>
가능한 숫자는 모두  의 형태를 띈다.<br><br>위의 표기는 비효율적이다.  의 경우, 101 개의 bit 가 필요하다.<br>
대신에,  로 표현한다.<br>
<br> : 부호로서, 1이라면 음수를, 0이라면 양수를 나타낸다. 
<br> : 2진수로 표현된 소수이다. 단, 다음 범위를 만족한다.

<br> 과  사이 혹은  과  사이


<br> :  로 표현되는  가 음수가 가능한 가중치를 의미한다.
<br>크게 4가지의 경우의 수가 있다.<br>
<img alt="PARA/Project/CS_APP_organize/chapter2/imgs/floating_point.png" src="lib/media/floating_point.png"><br>
single-precision format<br>
<br> : 1번째 bit
<br> : 8(= k) 번째 bit
<br> : 23(= n) 번째 bit
<br>double-precision format<br>
<br> : 1번째 bit
<br> : 11(= k) 번째 bit
<br> : 52(= n) 번째 bit
<br><br>가장 흔한 경우로,  의 bit 패턴이 모두 0이거나 모두 1이 아닌 경우이다.<br>
이 때, exponant value 는  로 해석된다.<br>
 는 부호 없는 bit 표현이며,  는  의 값을 갖는다.<br> 은 그 값을  라고 했을 때,  을 만족한다.<br>
 는  로 정의된다.  이것은  표현이라고 불린다.<br>
해당 값은 항상  을 가지기 때문에,  이며,<br>
1이 항상 지수부분에 오므로, 생략함으로서 비트를 효율적으로 사용한다.<br><br> 의 값이 모두 0 임을 의미한다.<br>
 를 가지며, significand 는  이다.<br>
즉,  의 적용이 되어있지 않다.<br>이 경우는 2가지의 목적이 있다.<br>첫번째는 0을 표현한다.<br>
Case 1 에서는 항상  이 1 이상이므로 0을 표현할 방법이 없다.<br>
모든 bit 가 0 인 것을 , 부호비트가 1이고 나머지가 모두 0인 것을  으로 해석한다.<br>
이 둘의 구분은 어떤 점에선 다르기도 하다.<br>2번째는 0.0 에 매우 가까운 숫자를 표현하는 것이다.<br>
0.0 에 가까워지는 숫자에게  라는 특성을 부여한다.<br><br>exponand 가 모두 1인 경우이다.<br>
fraction 부분이 모두 0이라면, 무한을 의미한다.  이라면  을,  이라면  이다.<br>
이는 결과가 OverFlow 임을 의미한다.<br>fraction 부분이 모두 0이 아니라면,  라고 부른다.<br><br><img alt="PARA/Project/CS_APP_organize/chapter2/imgs/floating_point_range.png" src="lib/media/floating_point_range.png"><br>한 가지 재미있는 특성은 이 bit 표현을 부호 없는 정수로 해석할 때,<br>
정렬 순서가 원래 의도인 floating-point 와 동일하다는 것이다.<br>
이는 정수와 정렬하는 방법과 동일한 방법으로 정렬하고자 하는 IEEE 의 의도된 설계이다.<br>앞에서 정수 표현과 소수 표현에서 일부 bit 패턴이 겹친다고 했고, 의도된 사항이라고 했는데,<br>
이는 소수 표현을 만드는 방법을 떠올리면 된다.<br>
먼저 해당하는 숫자를  로 표현하는데, 이 때  부분이 결국 정수 표현과 동일하다.<br>
따라서 소수 부분을 나타내는 부분이 정수와 일치할 수 있다.<br>]]></description><link>articles/chapter2/2.4-floating_points.html</link><guid isPermaLink="false">articles/chapter2/2.4-Floating_Points.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate><enclosure url="lib/media/floating_point.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/floating_point.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[7.1-Compiler_Drivers]]></title><description><![CDATA[ 
 <br> 는 필요에 따라<br>
preprocessor, compiler, assembler, linker 를 불러 사용한다.<br><br><br><img class="code-styler-icon" src="blob://eacd128d-f9de-4305-ac44-6a8699711843">code/link/main.c1	int sum(int *a, int n);2	int array[2] = {1, 2};3<br>4	int main() {5		int val = sum(array, 2);6		return val;7	}<br><br><br><img class="code-styler-icon" src="blob://eacd128d-f9de-4305-ac44-6a8699711843">code/link/sum.c1	int sum(int *a, int n) {2		int i, s = 0;3		for(i = 0; i &lt; n; i++) {4			s += a[i];5		}6		return s;7	}<br>2개의 파일을 이용해 하나의 실행파일 prog 를 만드는 과정을 살펴보자.<br>
이를 위해 명령어 gcc -0g -o prog main.c sum.c 를 실행시키게 된다.<br>driver는 첫번째로,  를 실행시킨다.<br>
이는 C 소스코드를 중간파일(ASCII intermediate file) 인,  로 만든다.<br>그 다음으로,  을 실행시킨다.<br>
이는 중간파일을 어셈블리 파일(ASCII assembly-language) 인,  로 만든다.<br> 을 실행시킨다.<br>
이는 어셈블리 파일을 재할당 가능한 이진 목적파일() 로 만든다.<br>sum.c 에 대해 동일한 과정을 거쳐, 목적파일을 만든다.<br>마지막으로,  을 실행시킨다.<br>
main.o, sum.o 그리고 다른 필요한 시스템목적파일과 함께, 실행가능한 이진파일() 을 만든다.<br>마지막으로 실행을 위해, ./prog 를 입력하는데, 이는<br>
터미널이 OS의 loader 라는 함수를 사용하는 것으로 이루어진다.<br>
loader 는 코드와 데이터를 메모리에 복사하고, 통제권을 프로그램의 시작부분으로 넘겨준다.<br><img alt="PARA/Project/CS_APP_organize/chapter7/imgs/static_linking.png" src="lib/media/static_linking.png">]]></description><link>articles/chapter7/7.1-compiler_drivers.html</link><guid isPermaLink="false">articles/chapter7/7.1-Compiler_Drivers.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate><enclosure url="blob:app://obsidian.md/eacd128d-f9de-4305-ac44-6a8699711843" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;blob:app://obsidian.md/eacd128d-f9de-4305-ac44-6a8699711843&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[7.2-Static_Linking]]></title><description><![CDATA[ 
 <br>Static Linker 는 input 으로 재할당 가능한 목적 파일들과 옵션 매개변수를 받아,<br>
실행 가능한 목적 파일을 생성한다.<br>재할당 가능한 목적파일은 내부에 코드와 데이터 영역(code, data section) 이 존재하는데,<br>
각 부분은 연속적인 바이트의 나열일 뿐이다.<br>명령어도 어떤 영역에 존재하는데, 다른 영역에 존재하는 전역변수를 초기화한다.<br>
또한 초기화되지 않은 변수는 또 다른 영역에 존재한다.<br>실행가능한 목적 파일을 위해, linker 는 아래의 2가지 일을 한다.<br>
<br>
<br>
목적 파일은  을 정의하고, 참조(reference) 한다.<br>
참조는 함수, 전역변수 등 다양하다.<br>
Symbol Resolution 은 각 symbol의 참조를 "정확히" 1개의 정의로 대응시키기 위함이다.

<br>
<br>
컴파일러와 어셈블러는 코드, 데이터 영역을 주소 0에서부터 시작한다.<br>
각 symbol 정의, 메모리 위치(Memory Location)를 고려하여, 각 영역을 재배치한다.<br>
재배치된 symbol 정의에 따라 참조 또한 그에 맞춰 변경한다.<br>
linker 는 어셈블러가 만들어준 명령어를 통해 재할당을 하는데,<br>
이 때 만들어진 명령어를 Relocation Entries 라고 한다.

<br>목적 파일은 바이트 덩어리(Blocks of Bytes) 의 조합일 뿐이다.<br>
이 덩어리는 코드를, 데이터를다른 데이터 구조 등등을 가지고 있을 수 있다.<br>
linker 는 이 덩어리들을 합치고, run-time 위치를 결정하며, 덩어리 안의 위치 또한 변경한다.<br>linker 는 해당 machine 에 대해 거의 이해하지 못한다.<br>
컴파일러와 어셈블러가 이미 대부분의 필요한 작업을 했기 때문이다.]]></description><link>articles/chapter7/7.2-static_linking.html</link><guid isPermaLink="false">articles/chapter7/7.2-Static_Linking.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate></item><item><title><![CDATA[7.3-Object_Files]]></title><description><![CDATA[ 
 <br>목적 파일은 크게 3가지 형태가 있다.<br>
<br>
<br>
이진 코드와 데이터를<br>
compile-time 에 다른 Relocatable Obj File 과 합칠 수 있는 형태로<br>
저장한다.

<br>
<br>
이진 코드와 데이터를<br>
메모리로 바로 복사될 수 있고, 실행가능한 형태로<br>
저장한다.

<br>
<br>
특별한 형태의 Relocatable Obj File이다.<br>
load-time, run-time 에<br>
메모리에 저장가능하며, liking 이 동적으로(Dynamic) 이루어질 수 있다.

<br>실제 바이트 덩어리는  이며,<br>
Object Module이 disk 에 저장되어 있을 때  이라고 한다.<br>
용어가 구분되어있지만, 혼용해서 사용한다.<br>Obj 파일은 specific Object File Format 이 존재하는데, 이는 시스템마다 다르다.<br>
그 중에서 해당 교재는 최신 Linux, Unix 시스템에서 사용하는<br>
Executable and Linkable Format(ELF) 형식을 사용하여 설명한다.<br>
하지만, 기본 개념은 특정 형식과 무관하게, 비슷하다.]]></description><link>articles/chapter7/7.3-object_files.html</link><guid isPermaLink="false">articles/chapter7/7.3-Object_Files.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate></item><item><title><![CDATA[7.4-Relocatable_Object_Files]]></title><description><![CDATA[ 
 <br><img alt="PARA/Project/CS_APP_organize/chapter7/imgs/ELF_relocatble_obj.png" src="lib/media/elf_relocatble_obj.png"><br>
ELF Header는<br>
16바이트 배열로 word 사이즈와 이 파일을 생성한 시스템의 바이트 순서가 저장되어있다.<br>
header 의 나머지 부분은 linker 가 목적파일을 파싱하고 해석하는데 필요한 정보가 담겨있다.<br>
이것은 ELF Header 의 사이즈, Obj 파일의 형식(relocatable, executable, shared),<br>
machine-type(x86-64...), section header table에 대한 file offset(base 주소로부터의 거리),<br>
section header table 로 향하는 entries 의 개수와 사이즈 가 있다.<br>section header table에는<br>
다양한 section에 대한 위치와 사리즈가 저장되어 있다.<br>
또한, 각 section 에 대한 고정된 크기의 entry 도 존재한다.<br>ELF Header 와 Section header Table 사이에는 실제 section 이 존재한다.<br>
보통은 아래와 같은 section 을 갖는다.<br>
<br><br>
컴파일된 프로그램이 machine code 형태로 저장되어있다.
<br><br>
Read-Only 데이터, Printf의 형식지정자, switch 문의 jump tables 등이 존재한다.
<br><br>
 된 전역, static 변수가 저장되어있다.<br>
지역변수는 stack 에 run-time 시에 존재하므로, data 나 아래의 bss에 존재하지 않는다.
<br><br>
 된 전역, static 변수, 0으로 초기화된 전역 static 변수가 저장되어있다.<br>
이 구역은 실제로는 공간을 차지하지 않는다.<br>
단순한 임시공간(PlaceHolder) 로 Obj 파일 형식은 공간효율을 위해 초기화, 비초기화 변수들을 구분한다.(초기화되지 않은 변수는 공간을 차지할 필요가 없다.)<br>
run-time 시에 이 변수들은 메모리에 0으로 초기화되면서 할당된다.
<br><br>
 이 저장되어있다.<br>
해당 테이블에는 프로그램에서 정의되고 사용되는(참조되는) 함수와 전역변수에 대한 정보가 담겨있다.<br>
모든 relocatable 목적파일은 symbol table 이 .symtab 에 존재한다.<br>
하지만, 컴파일러에 있는 symbol table 과 달리, 지역변수에 대한 접근은 존재하지 않는다.
<br><br>
.text 영역 중 linker 가 다른 목적파일과 연결할 때, 변경되어야하는 위치들의 모음이다.<br>
보통 전역변수나 외부 함수에 대한 call 을 나타내는 명령어가 해당된다.<br>
이 정보는 실제 실행목적파일에 필요하지 않기 때문에, 따로 linker에 포함해달라는 요청이 있지 않는 한, 제거된다.
<br><br>
전역변수에 대한 재할당 정보, 그중에서 모듈에 의해 참조되거나 정의된 정보에 해당한다.<br>
보통 전역변수나 외부 함수에 대한 주소를 초기값으로 갖는 초기화된 전역변수에 해당한다.
<br><br>
컴파일러에 -g 옵션(debugging information 생성 요청) 이 있을 경우, 만들어진다.<br>
지역변수, 프로그램 내 타입 정의, 프로그램 내에 정의되고 참조된 전역변수, C언어 소스코드 에 대한 entries 가 저장된 debugging symbol table 이 존재한다.
<br><br>
컴파일러에 -g 옵션(debugging information 생성 요청) 이 있을 경우, 만들어진다.<br>
line number 와 C언어 소스코드 간의 맵핑을 저장한다.
<br><br>
string table로, .symtab, .debug 영역의 symbol table, section header 에 존재하는 section 이름을 위해 존재한다.<br>
이 테이블은 null-terminated 문자열의 배열이다.
]]></description><link>articles/chapter7/7.4-relocatable_object_files.html</link><guid isPermaLink="false">articles/chapter7/7.4-Relocatable_Object_Files.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate><enclosure url="lib/media/elf_relocatble_obj.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/elf_relocatble_obj.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ch1-A_Tour_of_Computer_Systems]]></title><description><![CDATA[ 
 <br>컴퓨터 시스템은 하드웨어 + 소프트웨어의 조합으로 프로그램을 구동한다.<br>
특정 구현은 바뀔 수 있지만, 그 밑의 개념은 바뀌지 않는다.<br>
이 책은 프로그래머가 더 나은 프로그램 작성을 위해 필요한 지식을 정리한다.<br><a data-tooltip-position="top" aria-label="PARA/Project/CS_APP_organize/chapter1/1.1-Info=Bits+Context" data-href="PARA/Project/CS_APP_organize/chapter1/1.1-Info=Bits+Context" href="para/project/cs_app_organize/chapter1/1.1-info=bits+context.html" class="internal-link" target="_self" rel="noopener nofollow">1.1-Info=Bits+Context</a><br>
<a data-tooltip-position="top" aria-label="PARA/Project/CS_APP_organize/chapter1/1.2-Translate_Program" data-href="PARA/Project/CS_APP_organize/chapter1/1.2-Translate_Program" href="para/project/cs_app_organize/chapter1/1.2-translate_program.html" class="internal-link" target="_self" rel="noopener nofollow">1.2-Translate_Program</a><br>
<a data-tooltip-position="top" aria-label="PARA/Project/CS_APP_organize/chapter1/1.3-Importance_of_Understanding_Compiler" data-href="PARA/Project/CS_APP_organize/chapter1/1.3-Importance_of_Understanding_Compiler" href="para/project/cs_app_organize/chapter1/1.3-importance_of_understanding_compiler.html" class="internal-link" target="_self" rel="noopener nofollow">1.3-Importance_of_Understanding_Compiler</a><br>
<a data-tooltip-position="top" aria-label="PARA/Project/CS_APP_organize/chapter1/1.4-Proccessor_reads_Instruction_in_Memory" data-href="PARA/Project/CS_APP_organize/chapter1/1.4-Proccessor_reads_Instruction_in_Memory" href="para/project/cs_app_organize/chapter1/1.4-proccessor_reads_instruction_in_memory.html" class="internal-link" target="_self" rel="noopener nofollow">1.4-Proccessor_reads_Instruction_in_Memory</a><br>
<a data-tooltip-position="top" aria-label="PARA/Project/CS_APP_organize/chapter1/1.5-Cache_is_important" data-href="PARA/Project/CS_APP_organize/chapter1/1.5-Cache_is_important" href="para/project/cs_app_organize/chapter1/1.5-cache_is_important.html" class="internal-link" target="_self" rel="noopener nofollow">1.5-Cache_is_important</a><br>
<a data-tooltip-position="top" aria-label="PARA/Project/CS_APP_organize/chapter1/1.6-Hierarchy_of_Memory" data-href="PARA/Project/CS_APP_organize/chapter1/1.6-Hierarchy_of_Memory" href="para/project/cs_app_organize/chapter1/1.6-hierarchy_of_memory.html" class="internal-link" target="_self" rel="noopener nofollow">1.6-Hierarchy_of_Memory</a><br>
<a data-tooltip-position="top" aria-label="PARA/Project/CS_APP_organize/chapter1/1.7-OS_manage_Hardware" data-href="PARA/Project/CS_APP_organize/chapter1/1.7-OS_manage_Hardware" href="para/project/cs_app_organize/chapter1/1.7-os_manage_hardware.html" class="internal-link" target="_self" rel="noopener nofollow">1.7-OS_manage_Hardware</a><br>
<a data-tooltip-position="top" aria-label="PARA/Project/CS_APP_organize/chapter1/1.8-System_communicate_System_with_Network" data-href="PARA/Project/CS_APP_organize/chapter1/1.8-System_communicate_System_with_Network" href="para/project/cs_app_organize/chapter1/1.8-system_communicate_system_with_network.html" class="internal-link" target="_self" rel="noopener nofollow">1.8-System_communicate_System_with_Network</a><br>
<a data-tooltip-position="top" aria-label="PARA/Project/CS_APP_organize/chapter1/1.9-Other_important_Themes" data-href="PARA/Project/CS_APP_organize/chapter1/1.9-Other_important_Themes" href="para/project/cs_app_organize/chapter1/1.9-other_important_themes.html" class="internal-link" target="_self" rel="noopener nofollow">1.9-Other_important_Themes</a><br>
<a data-tooltip-position="top" aria-label="PARA/Project/CS_APP_organize/chapter1/1.10-Summary" data-href="PARA/Project/CS_APP_organize/chapter1/1.10-Summary" href="para/project/cs_app_organize/chapter1/1.10-summary.html" class="internal-link" target="_self" rel="noopener nofollow">1.10-Summary</a>]]></description><link>articles/ch1-a_tour_of_computer_systems.html</link><guid isPermaLink="false">articles/ch1-A_Tour_of_Computer_Systems.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate></item><item><title><![CDATA[ch2-Representing_and_Manipulating_Info]]></title><description><![CDATA[ 
 <br>컴퓨터는 정보를 2가지 값을 가지는 신호, 즉  로 표현한다.<br>
10진법은 오래동안 사용되었고, 우리에게 매우 익숙하지만, 정보를 표현하고 가공하는 기계에서는 2진법이 유용하다.<br>
예를 들어, 펀치카드릐의 구멍 유무, 전압의 고저, 자석의 시계, 반시계 반향 등등 다양하게 표현가능하다.<br>단일 bit만으로는 유용한 정보를 표현하기 어렵다.<br>
여러개의 bit가 모이고,  되면, 의미있게 사용될 수 있다.<br>
예를 들어 여러개의 bit 로 정수로 해석하여, 특정한 정수를 얻을 수 있다.<br>
그 외 다양한 해석 방법을 공부할 것이다.<br>
다룰 해석방법 중 중요한 아래 3가지 해석 방법을 공부한다.<br>
<br> 인코딩(자연수 표현)
<br> 인코딩(정수 표현)
<br> 인코딩(실수 표현)
<br>컴퓨터의 저장공간은 한정되어 있기 때문에, 숫자의 저장에는 한계가 있다.<br>
이로 인해 overflow 가 발생해 원치 않는 에러가 발생하곤 한다.<br>예시로, 200 * 300 * 400 * 500 은 -884,901,888 이 나오는등 수학과는 다른 점이 있다.<br>
또 다른것으로는<br>
이다. (교환 법칙이 성립하지 않았다!)<br>컴퓨터가 표현하는 방법을 공부함으로서, 표현가능한 범위와 수학과는 다른 연산 특징을 알 수 있다. 이 특성을 이해하는 것은 올바른 프로그램에 중요하다.<br>
이 교묘한 특성은 간혹 보안상의 문제의 원인이 되곤한다.<br>이 방법을 익히는 것은 또한 컴파일러가 연산을 최적화하는 방법을 이해하는데 필요하다.<br><a data-tooltip-position="top" aria-label="PARA/Project/CS_APP_organize/chapter2/2.1-Infomation_Storage" data-href="PARA/Project/CS_APP_organize/chapter2/2.1-Infomation_Storage" href="para/project/cs_app_organize/chapter2/2.1-infomation_storage.html" class="internal-link" target="_self" rel="noopener nofollow">2.1-Infomation_Storage</a><br>
<a data-tooltip-position="top" aria-label="PARA/Project/CS_APP_organize/chapter2/2.2-Integer_Representations" data-href="PARA/Project/CS_APP_organize/chapter2/2.2-Integer_Representations" href="para/project/cs_app_organize/chapter2/2.2-integer_representations.html" class="internal-link" target="_self" rel="noopener nofollow">2.2-Integer_Representations</a><br>
<a data-tooltip-position="top" aria-label="PARA/Project/CS_APP_organize/chapter2/2.3-Integer_Arithmetic" data-href="PARA/Project/CS_APP_organize/chapter2/2.3-Integer_Arithmetic" href="para/project/cs_app_organize/chapter2/2.3-integer_arithmetic.html" class="internal-link" target="_self" rel="noopener nofollow">2.3-Integer_Arithmetic</a><br>
<a data-tooltip-position="top" aria-label="PARA/Project/CS_APP_organize/chapter2/2.4-Floating_Points" data-href="PARA/Project/CS_APP_organize/chapter2/2.4-Floating_Points" href="para/project/cs_app_organize/chapter2/2.4-floating_points.html" class="internal-link" target="_self" rel="noopener nofollow">2.4-Floating_Points</a>]]></description><link>articles/ch2-representing_and_manipulating_info.html</link><guid isPermaLink="false">articles/ch2-Representing_and_Manipulating_Info.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate></item><item><title><![CDATA[ch7-Linking]]></title><description><![CDATA[ 
 <br> 이란, 여러 코드 조각들을 모아서 하나의 단일 파일로 만드는 것이다.<br>
 은<br>
<br>, 소스코드가 machine code 로 변환될 때, 
<br>, 메모리로 이동되고,  에 의해 실행될 때,
<br>, 프로그램이 실행될 때<br>
이루어진다.
<br>과거에는 수동으로 이루어졌지만, 현대에서는  에 의해 자동으로 이루어진다.<br>
 는  을 가능하게 해준다.<br>
이는 하나의 크고 긴 소스코드를 한번에 컴파일 하는 것이 아닌,<br>
더 작고 다루기 쉬운 모듈() 로 다룰 수 있게 해준다.<br>어떤 부분에서의 수정은 해당 모듈에 대한 수정, 즉 재컴파일만 이루어지면 된다.<br> 는  에 의해 자동적으로 수행되어지지만, 아래의 이유로 배워야한다.<br>
<br>
<br>
 의 작동원리를 아는 것은 라이브러리, 모듈의 연결 과정에서의 에러를 해결하는데 도움을 줄 수 있다.

<br>
<br>
linking 과정에서 프로그램의 정당성(correctness) 에 영향을 줄 수 있다.<br>
잘못 정의된 여러 전역변수는 linker 가 어떠한 에러도 보여주지 않는다.<br>
이것이 어떻게 발생하는지, 어떻게 해결하는지 살펴본다.

<br>
<br>
전역변수와 지역변수의 차이, static 으로 정의한 것의 의미가 무엇인지 등을 살펴본다.

<br>
<br>
linker 에 의해 만들어진 목적파일(object file)은 시스템 함수에서 중요한 역할을 한다.<br>
프로그램 로딩, 실행, 가상 메모리 등등이 있다.

<br>
<br>
과거에는 직관적인 일이었지만,<br>
shared libraries, dynamic linking 의 중요성이 부각되면서, 그 과정은 좀 더 정교해졌다.<br>
이에 따라 linking 은 유용한 도구가 되었다.<br>
예를 들어,  을 업데이트하는데에는, shared libraries 가 사용된다.<br>
 란, 중간 바이너리 파일로서, 시스템 종속성이 제거되어있어,<br>
여러 시스템에서 같은 파일로 사용할 수 있다는 장점이 있다. 각 시스템에서 linking 을 통해 시스템용 실행 파일로 변환된다.<br>
 dynamic linking 을 이용한다.

<br>이 챕터에서는 모든 linking 의 양상을 살펴본다.<br>
여기서는 특정 환경에 종속적으로 확인하지만, 주요한 컨셉은 다른 시스템에서도 동일하다.<br><a data-tooltip-position="top" aria-label="PARA/Project/CS_APP_organize/chapter7/7.1-Compiler_Drivers" data-href="PARA/Project/CS_APP_organize/chapter7/7.1-Compiler_Drivers" href="para/project/cs_app_organize/chapter7/7.1-compiler_drivers.html" class="internal-link" target="_self" rel="noopener nofollow">7.1-Compiler_Drivers</a><br>
<a data-tooltip-position="top" aria-label="PARA/Project/CS_APP_organize/chapter7/7.2-Static_Linking" data-href="PARA/Project/CS_APP_organize/chapter7/7.2-Static_Linking" href="para/project/cs_app_organize/chapter7/7.2-static_linking.html" class="internal-link" target="_self" rel="noopener nofollow">7.2-Static_Linking</a><br>
<a data-tooltip-position="top" aria-label="PARA/Project/CS_APP_organize/chapter7/7.4-Relocatable_Object_Files" data-href="PARA/Project/CS_APP_organize/chapter7/7.4-Relocatable_Object_Files" href="para/project/cs_app_organize/chapter7/7.4-relocatable_object_files.html" class="internal-link" target="_self" rel="noopener nofollow">7.4-Relocatable_Object_Files</a><br>
<a data-tooltip-position="top" aria-label="PARA/Project/CS_APP_organize/chapter7/7.4-Relocatable_Object_Files" data-href="PARA/Project/CS_APP_organize/chapter7/7.4-Relocatable_Object_Files" href="para/project/cs_app_organize/chapter7/7.4-relocatable_object_files.html" class="internal-link" target="_self" rel="noopener nofollow">7.4-Relocatable_Object_Files</a><br>아래는 해당 챕터에서 계속 살펴볼 2개의 소스코드이다.<br>	int sum(int *a, int n);
	int array[2] = {1, 2};

	int main() {
		int val = sum(array, 2);
		return val;
	}
<br>	int sum(int *a, int n) {
		int i, s = 0;
		for(i = 0; i &lt; n; i++) {
			s += a[i];
		}
		return s;
	}
]]></description><link>articles/ch7-linking.html</link><guid isPermaLink="false">articles/ch7-Linking.md</guid><pubDate>Fri, 02 May 2025 05:29:47 GMT</pubDate></item></channel></rss>